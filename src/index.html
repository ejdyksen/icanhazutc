<!DOCTYPE html>
<html>
<meta charset="utf-8">
<style>
:root {
  color-scheme: light dark;
}
</style>
<body>
<pre id="t"></pre>

<noscript><pre>JavaScript required</pre></noscript>

<script>
// Replaced by server at render time (ms since epoch). 0 means "unknown".
const SERVER_TIME_MS = 0;

const el = document.getElementById("t");
const fmt = d => d.toISOString().slice(0,19).replace("T"," ") + " UTC";

let isPaused = false;
let timeoutId = null;

// Establish base time (epoch) and its monotonic anchor (performance.now()).
let baseEpochMs;
let basePerf;

// Determine skew using server time if provided.
const hasServerTime = Number.isFinite(SERVER_TIME_MS) && SERVER_TIME_MS > 0;
const clockSkewMs = hasServerTime ? (SERVER_TIME_MS - Date.now()) : 0;
const showTimeWarning = hasServerTime && Math.abs(clockSkewMs) > 30_000; // 30s

function rebase(epochMs) {
  baseEpochMs = epochMs;
  basePerf = performance.now();
}

// Monotonic "now" in epoch ms, immune to user clock jumps.
function nowEpochMs() {
  return baseEpochMs + (performance.now() - basePerf);
}

function render(epochMs) {
  // When skew is large, show static server time with warning
  if (showTimeWarning) {
    const serverTime = fmt(new Date(SERVER_TIME_MS));
    const msg = `${serverTime}\n\nwarning, local clock may be inaccurate, using server time`;
    if (el.textContent !== msg) el.textContent = msg;
    return;
  }

  const s = fmt(new Date(epochMs));
  if (el.textContent !== s) el.textContent = s;
}

function scheduleNextTick() {
  if (isPaused || showTimeWarning) return;
  const epoch = nowEpochMs();
  const delay = 1000 - (epoch % 1000); // align to next exact second boundary
  clearTimeout(timeoutId);
  timeoutId = setTimeout(() => {
    // Slight guard: if timing slipped badly, recompute boundary on next loop
    render(nowEpochMs());
    scheduleNextTick();
  }, delay);
}

function startTimer() {
  // Seed from server time when available; otherwise fall back to local time.
  rebase(hasServerTime ? SERVER_TIME_MS : Date.now());
  render(nowEpochMs());
  scheduleNextTick();
}

function stopTimer() {
  clearTimeout(timeoutId);
  timeoutId = null;
}

function togglePause() {
  isPaused = !isPaused;
  el.style.opacity = isPaused ? "0.8" : "1";
  if (isPaused) {
    stopTimer();
  } else {
    // Recompute boundary on resume from pause.
    render(nowEpochMs());
    scheduleNextTick();
  }
}

// Pause on mouse down so text can be selected
el.addEventListener('mousedown', () => {
  if (!isPaused) {
    isPaused = true;
    el.style.opacity = "0.8";
    stopTimer();
  }
});

el.addEventListener('mouseup', () => {
  if (isPaused) {
    isPaused = false;
    el.style.opacity = "1";
    render(nowEpochMs());
    scheduleNextTick();
  }
});

// Handle case where mouse leaves element while down
el.addEventListener('mouseleave', () => {
  if (isPaused) {
    isPaused = false;
    el.style.opacity = "1";
    render(nowEpochMs());
    scheduleNextTick();
  }
});

// Avoid background work; recompute boundary when becoming visible.
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopTimer();
  } else if (!isPaused) {
    // Keep the same monotonic base; just re-align to the next boundary.
    render(nowEpochMs());
    scheduleNextTick();
  }
});

startTimer();
</script>
</body>
</html>
