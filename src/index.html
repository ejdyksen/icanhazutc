<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
  color-scheme: light dark;
}
</style>
<body>
<pre id="t"></pre>
<noscript><pre>JavaScript required</pre></noscript>
<script>

// Replaced by server at render time (ms since epoch). 0 means "unknown".
let SERVER_TIME_MS = 0;

const el = document.getElementById("t");
const fmt = d => d.toISOString().slice(0,19) + "Z";

let isPaused = false;
let timeoutId = null;
let rafId = null;
let nextSecondString = null; // Pre-computed string for next second

// Establish base time (epoch) and its monotonic anchor (performance.now()).
let baseEpochMs;
let basePerf;

// Determine skew using server time if provided.
const hasServerTime = Number.isFinite(SERVER_TIME_MS) && SERVER_TIME_MS > 0;
const clockSkewMs = hasServerTime ? (SERVER_TIME_MS - Date.now()) : 0;
const showTimeWarning = hasServerTime && Math.abs(clockSkewMs) > 60_000; // 60 sec

function rebase(epochMs) {
  baseEpochMs = epochMs;
  basePerf = performance.now();
}

// Monotonic "now" with sleep/wake detection.
function nowEpochMs() {
  const perfNow = performance.now();
  const monotonicTime = baseEpochMs + (perfNow - basePerf);
  const systemTime = Date.now();
  const drift = Math.abs(monotonicTime - systemTime);

  // If drift > 2 seconds, assume sleep/wake or time jump - resync immediately
  if (drift > 2_000) {
    rebase(systemTime);
    return systemTime;
  }

  return monotonicTime;
}

function render(epochMs, precomputedString) {
  // When skew is large, show static server time with warning
  if (showTimeWarning) {
    const serverTime = fmt(new Date(SERVER_TIME_MS));
    const msg = `${serverTime}\n\nwarning, local clock may be inaccurate, showing server time`;
    if (el.textContent !== msg) el.textContent = msg;
    return;
  }

  // Use pre-computed string if provided, otherwise format on demand
  const s = precomputedString || fmt(new Date(epochMs));
  if (el.textContent !== s) el.textContent = s;
}

function scheduleNextTick() {
  if (isPaused || showTimeWarning) return;
  clearTimeout(timeoutId);
  cancelAnimationFrame(rafId);

  function tick() {
    rafId = null; // Clear RAF id to prevent double scheduling
    if (isPaused || showTimeWarning) return;

    const now = nowEpochMs();
    const msIntoSecond = now % 1000;

    // Render when within one frame of second boundary
    if (msIntoSecond < 16) {
      const exactSecondTime = now - msIntoSecond;
      render(exactSecondTime, nextSecondString);
      nextSecondString = null; // Clear after use
    }

    // Pre-compute next second's string when we're approaching it
    if (msIntoSecond > 950 && !nextSecondString) {
      const nextSecondTime = now - msIntoSecond + 1000;
      nextSecondString = fmt(new Date(nextSecondTime));
    }

    if (msIntoSecond < 200 || msIntoSecond > 800) {
      // Near second boundary - use RAF for precision
      rafId = requestAnimationFrame(tick);
    } else {
      // Far from boundary - sleep until we're close (800ms mark)
      const msUntilNearBoundary = 800 - msIntoSecond;
      timeoutId = setTimeout(tick, msUntilNearBoundary);
    }
  }

  tick();
}

function startTimer() {
  // Seed from server time when available; otherwise fall back to local time.
  rebase(hasServerTime ? SERVER_TIME_MS : Date.now());
  render(nowEpochMs());
  scheduleNextTick();
}

function stopTimer() {
  clearTimeout(timeoutId);
  timeoutId = null;
  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = null;
  }
}

function togglePause() {
  isPaused = !isPaused;
  el.style.opacity = isPaused ? "0.8" : "1";
  if (isPaused) {
    stopTimer();
  } else {
    // Resume immediately
    render(nowEpochMs());
    scheduleNextTick();
  }
}

// Handle selection changes (keyboard selection, programmatic, etc.)
document.addEventListener('selectionchange', () => {
  const hasSelection = window.getSelection().toString().length > 0;

  if (hasSelection && !isPaused) {
    // Text selected, pause timer
    isPaused = true;
    el.style.opacity = "0.8";
    stopTimer();
  } else if (!hasSelection && isPaused) {
    // No text selected, resume timer
    isPaused = false;
    el.style.opacity = "1";
    render(nowEpochMs());
    scheduleNextTick();
  }
});

// Avoid background work; recompute boundary when becoming visible.
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopTimer();
  } else if (!isPaused) {
    // Keep the same monotonic base; just re-align to the next boundary.
    render(nowEpochMs());
    scheduleNextTick();
  }
});

startTimer();
</script>
</body>
</html>
